//Пирамидальная сортировка, исходный код был написан на Python, ниже представлена его реализация на Java
public class Main {
    // метод для преобразования массива в max-heap (перед сортировкой)
    static void heapify(int[] arr, int n, int i) { // объявление метода, который принимает массив целых чисел, длину массива и индекс текущего узла
        int largest = i; // переменная largest хранит индекс текущего узла, предполагаем, что он самый большой
        int left = 2 * i + 1; // индекс левого дочернего элемента текущего узла
        int right = 2 * i + 2; // индекс правого дочернего элемента: аналогично формуле для правого ребенка

        // здесь начинается сравнение дочерних элементов с текущим
        if (left < n && arr[left] > arr[largest]) // если левый дочерний индекс меньше длины массива (то есть элемент существует), и значение этого элемента больше значения по индексу largest
            largest = left; // тогда обновляем переменную largest, указывающую на индекс наибольшего элемента, чтобы он указывал на левый дочерний
        if (right < n && arr[right] > arr[largest]) // также для правого дочернего: если существует и больше текущего наибольшего
            largest = right; // обновляем largest, чтобы он указывал на индекс правого дочернего, если он больше
        if (largest != i) { // если после сравнения largest отличается от исходного i, значит найден больший элемент среди текущего и дочерних
            int swap = arr[i]; // временная переменная swap для хранения значения элемента по текущему индексу i
            arr[i] = arr[largest]; // меняем местами значения текущего элемента и большего из дочерних
            arr[largest] = swap; //  присваиваем значение из переменной swap

            heapify(arr, n, largest); // вызываем heapify для поддерева, чтобы восстановить свойства кучи (чтобы в вершине стоял наибольший элемент)
        }
    }

    static void heapSort(int[] arr) { // метод сортировки массива с помощью алгоритма heapSort (алгоритм сортировки массива, который использует структуру данных max-heap)
        int n = arr.length; // получаем длину массива, запоминаем в переменную n

        // преобразуем весь массив в структуру max-heap
        for (int i = n / 2 - 1; i >= 0; i--) { // проходим по внутренним узлам дерева, начиная с последнего, идущего к корню
            heapify(arr, n, i); // Восстанавливаем свойства max-heap, вызывая heapify для каждого узла
        }

        // теперь извлекаем по одному максимальный элемент и размещаем его в конце массива
        for (int i = n - 1; i > 0; i--) { // обратный цикл, уменьшаем размер рассматриваемой части массива
            // обмен местами корня (максимума) с последним элементом текущего участка массива
            int temp = arr[0]; // временная переменная temp для хранения значения корня
            arr[0] = arr[i]; // перемещаем последний элемент в позицию корня
            arr[i] = temp; // ставим старый корень в конец массива

            // восстановление свойств max-heap для уменьшенной части массива
            heapify(arr, i, 0); // вызываем heapify
        }
    }

    public static void main(String[] args) { // вход в программу
        int[] arr = {12, 11, 13, 5, 6, 7}; // создаем массив
        System.out.println("Исходный массив: "); // выводит строку
        for (int num : arr) { // проходится по массиву
            System.out.print(num + " "); // выводит каждый элемент массива с пробелом
        }
        System.out.println(); // переход на новую строку

        heapSort(arr); // вызываем метод сортировки

        System.out.println("Отсортированный массив: "); // выводит строку
        for (int num : arr) { // проходится по массиву
            System.out.print(num + " "); // выводит каждый элемент отсортированного массива с пробелом
        }
        System.out.println(); // переход на новую строку
    }
}
