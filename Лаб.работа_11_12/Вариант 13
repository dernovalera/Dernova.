def solve_n_queens(n):  # объявление функции
    solutions = []  # список, куда будем добавлять найденные расстановки (каждая — список столбцов)
    queens = [-1] * n  # список, где каждая строка доски изначально пустая (в строке i ферзь будет стоять в столбце j)
    def is_safe(row, col):  # проверка безопасности: можно ли поставить ферзя в (row(строка), col(столбец))
        for r in range(row):  # перебираем все строки выше текущей
            c = queens[r]  # в строке r ферзь стоит в столбце c
            if c == col:  # если столбец совпадает, значит ферзи бьют друг друга
                return False
            if abs(c - col) == abs(r - row):  # проверяем главную диагональ и побочную
                return False
        return True  # если нет конфликтов, значит безопасно
    def backtrack(row):  # рекурсивная функция, ставим ферзя в строку row
        if row == n:  # если расставили ферзей во всех n строках
            solutions.append(queens.copy())  # сохраняем копию решения
            return
        for col in range(n):  # пробуем поставить ферзя в любой столбец текущей строки
            if is_safe(row, col):  # если можно поставить ферзя в (row, col)
                queens[row] = col  # ставим ферзя (запоминаем столбец)
                backtrack(row+1)  # рекурсивно ставим ферзя в следующей строке
                queens[row] = -1  # откат (удаляем ферзя), чтобы можно было попробовать другой столбец
    backtrack(0)  # запускаем backtracking с 0-й строки
    return solutions  # возвращаем список всех решений
sols = solve_n_queens(8)
print("Найдено решений:", len(sols))
